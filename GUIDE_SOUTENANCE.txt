================================================================================
                    GUIDE DE SOUTENANCE - PROJET MORPION RPG
                          Base de Donn√©es et Programmation Web
================================================================================

üéØ DUR√âE TOTALE : 20 minutes (5 min d√©mo + 15 min questions)

================================================================================
                        PARTIE 1 : D√âMONSTRATION (5 MINUTES)
================================================================================

üìù SCRIPT DE PR√âSENTATION
--------------------------

[INTRODUCTION - 30 secondes]
"Bonjour, nous allons vous pr√©senter notre projet : un jeu de morpion avanc√© 
avec syst√®me de combat RPG. Notre application permet de jouer au morpion 
classique, mais aussi une version avanc√©e avec des morpions qui ont des 
statistiques (PV, attaque, mana, r√©ussite) et peuvent s'affronter avec des 
attaques et des sorts magiques."


[D√âMONSTRATION BASE DE DONN√âES - 1 minute]
"Commen√ßons par la structure de notre base de donn√©es PostgreSQL. Nous avons 
impl√©ment√© 6 tables :
- morpions : contient les statistiques de chaque morpion avec une contrainte 
  CHECK pour que la somme des points soit toujours 15
- equipes : stocke les √©quipes avec leur nom et couleur uniques
- equipes_morpions : table d'association N:M entre √©quipes et morpions
- configurations : d√©finit la taille de grille et nombre de tours maximum
- parties : enregistre chaque partie jou√©e avec les √©quipes et le gagnant
- journal : historise toutes les actions de chaque partie

Notre base contient 6 √©quipes diff√©rentes avec chacune entre 6 et 8 morpions."


[D√âMONSTRATION MODE NORMAL - 1 minute]
"Montrons d'abord le mode classique. Je clique sur 'Jouer', je choisis deux 
√©quipes [choisir Les Dragons de Feu vs Les Gardiens du Cristal], une 
configuration 3x3 avec 9 tours maximum.

[Placer quelques morpions rapidement]
Chaque joueur place ses morpions √† tour de r√¥le. Quand un joueur r√©alise un 
alignement de 3, il gagne avec un message de victoire et des animations 
c√©l√©bratoires."


[D√âMONSTRATION MODE AVANC√â - 2 minutes]
"Le mode avanc√© est plus complexe. Je s√©lectionne 'Jouer mode avanc√©', les 
m√™mes √©quipes, une grille 4x4 avec 16 tours maximum.

[Placer un morpion]
On voit que chaque morpion a des statistiques : PV, attaque, mana et r√©ussite. 
Le panneau de gauche montre l'√©quipe 1 en bleu, celui de droite l'√©quipe 2 en 
rouge. Les morpions disponibles sont list√©s, et ceux plac√©s apparaissent sur 
la grille avec leurs stats.

[Effectuer une attaque]
Maintenant je place un morpion ennemi adjacent et je lance une attaque. La 
r√©ussite est calcul√©e avec un tirage al√©atoire. Si l'attaque r√©ussit, elle 
inflige des d√©g√¢ts. Quand les PV tombent √† 0, le morpion meurt et dispara√Æt 
de la grille.

[Lancer un sort]
Nous avons impl√©ment√© 3 sorts :
- Boule de feu : co√ªte 2 mana, inflige 3 d√©g√¢ts √† un ennemi
- Sort de soin : co√ªte 1 mana, redonne 2 PV √† un alli√©
- Armageddon : co√ªte 5 mana, d√©truit d√©finitivement une case de la grille

[Si le temps le permet, montrer Armageddon]
Regardez, apr√®s l'Armageddon, la case est d√©truite et ne peut plus √™tre utilis√©e.

Les conditions de victoire sont multiples : alignement de N morpions, tous les 
ennemis √©limin√©s, adversaire ne pouvant plus agir, ou nombre maximum de tours 
atteint."


[CONCLUSION - 30 secondes]
"Toutes les parties et actions sont enregistr√©es en base de donn√©es dans les 
tables parties et journal. Notre projet respecte l'architecture MVC avec des 
contr√¥leurs Python, des templates Jinja2 et un mod√®le pour l'acc√®s aux donn√©es."


================================================================================
                    PARTIE 2 : QUESTIONS POSSIBLES (15 MINUTES)
================================================================================

üìö QUESTIONS SUR LA BASE DE DONN√âES
------------------------------------

Q1 : Expliquez votre sch√©ma relationnel.
R : Nous avons 6 tables :
    - MORPIONS(#id_morpion, nom, image, points_vie, points_attaque, 
      points_mana, points_reussite)
    - EQUIPES(#id_equipe, nom, couleur, date_creation)
    - EQUIPES_MORPIONS(#p(id_equipe), #p(id_morpion)) - cl√© primaire composite
    - CONFIGURATIONS(#id_configuration, taille_grille, nb_tours_max)
    - PARTIES(#id_partie, id_equipe_a, id_equipe_b, id_configuration, 
      date_debut, date_fin, id_equipe_gagnante)
    - JOURNAL(#p(id_partie), #p(numero_action), date_action, texte_action)
    
    Les relations sont : morpions N:M equipes via equipes_morpions, 
    configurations 1:N parties, equipes 1:N parties (3 fois : equipe_a, 
    equipe_b, gagnante), parties 1:N journal.


Q2 : Pourquoi avoir utilis√© une contrainte CHECK sur morpions ?
R : Pour garantir l'√©quilibre du jeu. Chaque morpion doit avoir exactement 
    15 points r√©partis entre PV, attaque, mana et r√©ussite. Cela emp√™che 
    d'avoir un morpion trop puissant avec des stats maximales partout.
    Contrainte : CHECK(points_attaque + points_mana + points_reussite + 
    points_vie = 15)


Q3 : Expliquez les cl√©s √©trang√®res de la table PARTIES.
R : PARTIES a 4 cl√©s √©trang√®res :
    - id_equipe_a REFERENCES equipes(id_equipe) ON DELETE CASCADE
    - id_equipe_b REFERENCES equipes(id_equipe) ON DELETE CASCADE
    - id_configuration REFERENCES configurations(id_configuration) ON DELETE CASCADE
    - id_equipe_gagnante REFERENCES equipes(id_equipe) ON DELETE SET NULL
    
    Les 3 premi√®res utilisent CASCADE car si une √©quipe ou configuration est 
    supprim√©e, les parties associ√©es n'ont plus de sens. La derni√®re utilise 
    SET NULL car on veut garder l'historique des parties m√™me si l'√©quipe 
    gagnante est supprim√©e.


Q4 : Quelle est la cardinalit√© entre morpions et equipes ?
R : C'est une relation plusieurs-√†-plusieurs (N:M). Un morpion peut appartenir 
    √† plusieurs √©quipes diff√©rentes, et une √©quipe poss√®de plusieurs morpions 
    (entre 6 et 8 dans notre base). Cette relation N:M est mat√©rialis√©e par 
    la table d'association EQUIPES_MORPIONS avec une cl√© primaire composite.


Q5 : Comment g√©rez-vous l'historique des parties ?
R : Via deux tables :
    1) PARTIES : stocke les m√©tadonn√©es (√©quipes, dates, gagnant)
    2) JOURNAL : stocke chaque action avec un num√©ro d'action s√©quentiel
    
    La cl√© primaire de JOURNAL est composite (id_partie, numero_action), ce 
    qui permet de num√©roter les actions dans chaque partie ind√©pendamment.


Q6 : √âcrivez une requ√™te SQL pour trouver l'√©quipe ayant gagn√© le plus de parties.
R : SELECT e.nom, COUNT(*) as nb_victoires
    FROM equipes e
    JOIN parties p ON e.id_equipe = p.id_equipe_gagnante
    GROUP BY e.id_equipe, e.nom
    ORDER BY nb_victoires DESC
    LIMIT 1;


Q7 : Comment r√©cup√©rer tous les morpions d'une √©quipe ?
R : SELECT m.id_morpion, m.nom, m.points_vie, m.points_attaque, 
           m.points_mana, m.points_reussite
    FROM morpions m
    JOIN equipes_morpions em ON m.id_morpion = em.id_morpion
    WHERE em.id_equipe = ?;
    
    C'est ce que fait la fonction get_morpions_equipe() dans morpion_model.py.


Q8 : Pourquoi date_fin et id_equipe_gagnante sont NULL dans PARTIES ?
R : date_fin est NULL quand la partie est en cours. id_equipe_gagnante est 
    NULL pour les parties non termin√©es ou les matchs nuls (quand le nombre 
    maximum de tours est atteint sans vainqueur).


üìù QUESTIONS SUR LE SQL
-----------------------

Q9 : Quelle est la diff√©rence entre WHERE et HAVING ?
R : WHERE filtre les lignes avant le regroupement (GROUP BY), tandis que 
    HAVING filtre apr√®s le regroupement. WHERE s'applique aux lignes 
    individuelles, HAVING aux groupes.
    Exemple : WHERE points_vie > 5 filtre les morpions,
              HAVING COUNT(*) > 3 filtre les groupes.


Q10 : Qu'est-ce qu'une jointure interne (INNER JOIN) ?
R : Une jointure qui ne retourne que les lignes ayant une correspondance dans 
    les deux tables. Par exemple, JOIN equipes_morpions ne retournera que les 
    morpions qui appartiennent √† au moins une √©quipe.


Q11 : Quelle est la diff√©rence entre UNION et UNION ALL ?
R : UNION √©limine les doublons et trie les r√©sultats, UNION ALL garde tous 
    les r√©sultats y compris les doublons. UNION ALL est plus rapide car pas 
    de d√©doublonnage ni de tri.


Q12 : Qu'est-ce qu'une sous-requ√™te corr√©l√©e ?
R : Une sous-requ√™te qui r√©f√©rence des colonnes de la requ√™te externe. Elle 
    est ex√©cut√©e une fois par ligne de la requ√™te externe.
    Exemple : SELECT nom FROM morpions m1 WHERE points_vie > 
              (SELECT AVG(points_vie) FROM morpions m2 WHERE m2.id_morpion = m1.id_morpion)


Q13 : Expliquez les op√©rations CASCADE et SET NULL.
R : CASCADE : quand on supprime une ligne, toutes les lignes li√©es dans 
              d'autres tables sont aussi supprim√©es automatiquement
    SET NULL : quand on supprime une ligne, les cl√©s √©trang√®res qui y font 
               r√©f√©rence sont mises √† NULL
    Utilis√© avec ON DELETE ou ON UPDATE.


üêç QUESTIONS SUR PYTHON
------------------------

Q14 : Expliquez la structure de votre code Python (avance.py).
R : Le fichier avance.py est un contr√¥leur qui :
    1) R√©cup√®re les param√®tres de SESSION (√©quipes, configuration)
    2) Initialise la partie avec un dictionnaire 'partie_avancee' dans SESSION
    3) Traite les actions POST (placer, attaquer, sort)
    4) Met √† jour l'√©tat des morpions (PV, mana, position)
    5) V√©rifie les conditions de victoire
    6) Enregistre les actions en base via morpion_model.py
    7) Passe les donn√©es √† afficher via REQUEST_VARS au template


Q15 : Comment g√©rez-vous l'√©tat de la partie entre les requ√™tes ?
R : Via la variable SESSION c√¥t√© serveur. SESSION['partie_avancee'] est un 
    dictionnaire contenant :
    - grille : tableau 2D avec les positions des morpions
    - morpions_etat : dictionnaire {id: {nom, pv, attaque, mana, ligne, col}}
    - cases_detruites : ensemble des coordonn√©es d√©truites par Armageddon
    - tour, joueur_actuel, nb_tours_max : gestion du d√©roulement
    - id_partie : r√©f√©rence en base de donn√©es


Q16 : Comment fonctionne le syst√®me de r√©ussite des attaques ?
R : 1) Chaque morpion a un attribut 'reussite' (valeur entre 1 et 10)
    2) On calcule proba_reussite = min(100, reussite * 10) en pourcentage
    3) On tire un nombre al√©atoire entre 0 et 100 avec random.randint()
    4) Si tirage <= proba_reussite, l'attaque/sort r√©ussit
    5) En cas de succ√®s, la r√©ussite augmente de 0.5 pour les prochaines actions


Q17 : Expliquez la v√©rification d'adjacence pour les attaques.
R : dist_l = abs(attaquant['ligne'] - cible['ligne'])
    dist_c = abs(attaquant['col'] - cible['col'])
    
    Adjacent = (dist_l == 1 et dist_c == 0) OU (dist_l == 0 et dist_c == 1)
    
    Cela v√©rifie que la cible est juste √† c√¥t√© horizontalement ou verticalement,
    mais pas en diagonale.


Q18 : Comment emp√™chez-vous les attaques entre alli√©s ?
R : Avant chaque attaque ou sort offensif, on v√©rifie :
    if attaquant['equipe'] == cible['equipe']:
        REQUEST_VARS['message'] = ('error', "Pas d'attaque entre alli√©s ! üõ°Ô∏è")
    
    Pour le sort de soin, c'est l'inverse :
    if lanceur['equipe'] != cible['equipe']:
        REQUEST_VARS['message'] = ('error', "Impossible de soigner un ennemi ! ‚öîÔ∏è")


Q19 : Quelles sont les conditions de victoire ?
R : 1) Alignement de N morpions (ligne, colonne ou diagonale)
    2) Tous les morpions adverses plac√©s sont morts
    3) L'adversaire ne peut plus agir (aucun morpion vivant sur la grille)
    4) Nombre maximum de tours atteint (match nul)
    
    On v√©rifie apr√®s chaque action dans verifier_victoire().


Q20 : Comment fonctionnent les trois sorts ?
R : - Boule de feu : co√ªt 2 mana, inflige 3 d√©g√¢ts √† un ennemi adjacent
    - Sort de soin : co√ªt 1 mana, +2 PV √† un alli√© (max = pv_max)
    - Armageddon : co√ªt 5 mana, tue le morpion cibl√© et d√©truit la case 
                   d√©finitivement (ajout√©e √† cases_detruites)
    
    Chaque sort v√©rifie le mana disponible, fait un test de r√©ussite, d√©duit 
    le co√ªt et applique l'effet.


üåê QUESTIONS SUR HTML/CSS/JINJA2
---------------------------------

Q21 : Qu'est-ce que Jinja2 et comment l'utilisez-vous ?
R : Jinja2 est un moteur de templates Python. Il permet d'ins√©rer des variables 
    et de la logique dans le HTML :
    - {{ variable }} : affiche une variable
    - {% if condition %} : structures conditionnelles
    - {% for item in liste %} : boucles
    - {% extends "base.html" %} : h√©ritage de templates
    - {% block nom %} : d√©finit des zones rempla√ßables


Q22 : Expliquez la structure de votre template avance.html.
R : 1) {% extends "base.html" %} : h√©rite de la structure commune
    2) {% block main_content %} : contenu sp√©cifique
    3) Affichage du message (victoire, succ√®s, erreur)
    4) Si partie termin√©e : bouton "Nouvelle Partie"
    5) Si grille existe :
       - En-t√™te avec tour actuel et joueur
       - 3 colonnes : √©quipe 1 (bleu) | grille centrale | √©quipe 2 (rouge)
       - Chaque √©quipe liste morpions disponibles et plac√©s avec code couleur 
         selon PV restants
       - Grille en CSS Grid avec cases color√©es selon √©quipe ou d√©truites
       - 3 formulaires d'actions (placer, attaquer, sort)


Q23 : Comment affichez-vous la grille de jeu ?
R : Avec CSS Grid :
    <div style="display: grid; grid-template-columns: repeat(4, 80px); gap: 5px;">
      {% for i in range(taille_grille) %}
        {% for j in range(taille_grille) %}
          <div style="...background selon √©tat...">
            {% if case d√©truite %}‚ò†Ô∏è
            {% elif morpion pr√©sent %}stats du morpion
            {% else %}coordonn√©es vides
            {% endif %}
          </div>
        {% endfor %}
      {% endfor %}
    </div>


Q24 : Comment indiquez-vous visuellement l'√©tat de sant√© des morpions ?
R : Avec des couleurs de fond conditionnelles :
    {% if etat.pv <= etat.pv_max / 3 %}#ffcdd2 (rouge clair = critique)
    {% elif etat.pv <= etat.pv_max / 2 %}#fff9c4 (jaune = bless√©)
    {% else %}white (blanc = bonne sant√©)
    {% endif %}


Q25 : Expliquez l'utilisation de REQUEST_VARS.
R : REQUEST_VARS est un dictionnaire pass√© du contr√¥leur Python au template 
    Jinja2. Il contient toutes les donn√©es √† afficher :
    - REQUEST_VARS['grille'] : √©tat de la grille
    - REQUEST_VARS['partie'] : infos sur la partie en cours
    - REQUEST_VARS['message'] : tuple (type, texte) pour les notifications
    - REQUEST_VARS['morpions1'], ['morpions2'] : listes des morpions
    - REQUEST_VARS['partie_terminee'] : bool√©en pour masquer les actions


üèóÔ∏è QUESTIONS SUR L'ARCHITECTURE MVC
-------------------------------------

Q26 : Expliquez l'architecture MVC de votre projet.
R : Mod√®le-Vue-Contr√¥leur :
    - MOD√àLE (model/morpion_model.py) : fonctions d'acc√®s √† la base de donn√©es
      (get_equipes, get_morpions_equipe, creer_partie, terminer_partie, etc.)
    - VUE (templates/*.html) : templates Jinja2 pour l'affichage HTML
    - CONTR√îLEUR (controleurs/*.py) : logique m√©tier, traitement des requ√™tes,
      pr√©paration des donn√©es pour la vue
    
    Le contr√¥leur ne fait JAMAIS de SQL directement, il appelle le mod√®le.
    La vue ne contient AUCUNE logique m√©tier, juste de l'affichage.


Q27 : Pourquoi s√©parer le mod√®le du contr√¥leur ?
R : - R√©utilisabilit√© : les fonctions du mod√®le peuvent √™tre utilis√©es par 
      plusieurs contr√¥leurs
    - Maintenabilit√© : si la structure de la BD change, on ne modifie que le mod√®le
    - Testabilit√© : on peut tester les requ√™tes SQL ind√©pendamment de la logique
    - S√©curit√© : centralisation des requ√™tes SQL avec requ√™tes pr√©par√©es


Q28 : Comment g√©rez-vous les formulaires ?
R : 1) Le template affiche un <form method="post" action="/avance">
    2) Chaque formulaire a un <input type="hidden" name="action_type" value="...">
    3) Le contr√¥leur r√©cup√®re les donn√©es avec POST.get('action_type', [None])[0]
    4) Un if/elif/else traite chaque type d'action
    5) Apr√®s traitement, on stocke un message dans REQUEST_VARS['message']
    6) Le template affiche le message avec le style appropri√©


Q29 : Qu'est-ce que routes.toml ?
R : C'est le fichier de configuration qui associe les URLs aux contr√¥leurs :
    [jouer]
    chemin = "/jouer"
    controleur = "jouer.py"
    
    [avance]
    chemin = "/avance"
    controleur = "avance.py"
    
    Quand l'utilisateur acc√®de √† /avance, le serveur bdw-server ex√©cute 
    controleurs/avance.py.


Q30 : Comment les sessions fonctionnent-elles dans votre application ?
R : SESSION est un dictionnaire c√¥t√© serveur maintenu entre les requ√™tes HTTP.
    Il contient :
    - SESSION['CONNEXION'] : connexion PostgreSQL
    - SESSION['HISTORIQUE'] : liste des actions utilisateur
    - SESSION['equipes1'], ['equipes2'] : √©quipes choisies
    - SESSION['taille_grille'], ['nb_tours_max'] : configuration
    - SESSION['partie_avancee'] : √©tat complet de la partie en cours
    
    Les donn√©es persistent jusqu'√† suppression explicite ou fin de session.


üîß QUESTIONS TECHNIQUES AVANC√âES
---------------------------------

Q31 : Comment g√©rez-vous la concurrence d'acc√®s √† la base ?
R : - Chaque requ√™te a sa propre SESSION['CONNEXION']
    - On fait commit() apr√®s chaque modification importante
    - Les transactions isolent les modifications d'une session
    - PostgreSQL g√®re les verrous automatiquement


Q32 : Pourquoi utiliser SERIAL pour les cl√©s primaires ?
R : SERIAL est un type PostgreSQL qui auto-incr√©mente automatiquement. Cela 
    garantit l'unicit√© des cl√©s primaires sans avoir √† g√©rer manuellement les 
    IDs. √âquivalent √† INTEGER avec une s√©quence automatique.


Q33 : Comment emp√™chez-vous les injections SQL ?
R : En utilisant des requ√™tes pr√©par√©es avec des param√®tres :
    cur.execute("SELECT * FROM morpions WHERE id_morpion = %s", (id_morpion,))
    
    JAMAIS de concat√©nation de cha√Ænes :
    # DANGEREUX : cur.execute(f"SELECT * FROM morpions WHERE id = {id}")


Q34 : Expliquez la fonction enregistrer_action().
R : def enregistrer_action(texte):
        try:
            ajouter_action_journal(SESSION['CONNEXION'], partie['id_partie'], 
                                 partie['numero_action'], texte)
            SESSION['CONNEXION'].commit()
            partie['numero_action'] += 1
        except Exception as e:
            pass  # Ignorer les erreurs
    
    Elle ins√®re une ligne dans la table JOURNAL avec le texte de l'action, 
    incr√©mente le num√©ro d'action, et commit. Le try/except √©vite que le jeu 
    plante si l'enregistrement √©choue.


Q35 : Comment g√©rez-vous le changement de joueur ?
R : Apr√®s chaque action r√©ussie (placement, attaque, sort) :
    partie['joueur_actuel'] = 2 if partie['joueur_actuel'] == 1 else 1
    partie['tour'] += 1
    
    On alterne entre 1 et 2, et on incr√©mente le compteur de tours.


üìä QUESTIONS SUR LES CHOIX DE CONCEPTION
-----------------------------------------

Q36 : Pourquoi avoir cr√©√© deux modes de jeu ?
R : Pour montrer notre ma√Ætrise de diff√©rentes complexit√©s :
    - Mode normal : impl√©mentation simple du morpion classique
    - Mode avanc√© : logique complexe avec gestion d'√©tat, combats, sorts, 
                    conditions multiples de victoire
    Cela d√©montre notre capacit√© √† cr√©er des applications web √©volutives.


Q37 : Pourquoi utiliser des dictionnaires pour morpions_etat ?
R : Les dictionnaires Python offrent un acc√®s en O(1) par id_morpion, ce qui 
    est plus rapide qu'une liste. Ils permettent aussi de stocker toutes les 
    donn√©es d'un morpion (PV actuels, mana, position) sans modifier la base.


Q38 : Pourquoi utiliser un set() pour cases_detruites ?
R : Les sets Python garantissent l'unicit√© et permettent de v√©rifier rapidement 
    si une case est d√©truite avec l'op√©ration 'in' en O(1). C'est plus efficace 
    qu'une liste.


Q39 : Pourquoi stocker l'√©tat dans SESSION plut√¥t qu'en base de donn√©es ?
R : Pour la performance : on √©vite de faire des requ√™tes SQL √† chaque action.
    L'√©tat complet est en m√©moire. On sauvegarde seulement les actions dans 
    JOURNAL pour l'historique. √Ä la fin, on enregistre le r√©sultat dans PARTIES.


Q40 : Comment am√©lioreriez-vous ce projet ?
R : Plusieurs pistes :
    - Syst√®me de comptes utilisateurs avec authentification
    - Mode multijoueur en ligne avec WebSockets
    - Intelligence artificielle pour jouer contre l'ordinateur
    - Syst√®me de classement et statistiques avanc√©es
    - Interface graphique plus riche avec animations JavaScript
    - Tests unitaires automatis√©s
    - Gestion des erreurs plus robuste avec logs


================================================================================
                                CONSEILS FINAUX
================================================================================

‚úÖ √Ä FAIRE :
- Parler clairement et calmement
- Donner des r√©ponses concises
- Dire "Je ne sais pas" si vous ne savez pas
- Avoir le code source ouvert et navigable rapidement
- Montrer votre ma√Ætrise technique sans h√©sitation
- Pr√©parer votre d√©mo pour qu'elle ne dure QUE 5 minutes
- Vous entra√Æner √† pr√©senter ensemble

‚ùå √Ä √âVITER :
- Perdre du temps sur des d√©tails non essentiels
- Montrer toutes les pages une par une sans but
- D√©passer les 5 minutes de d√©mo (p√©nalit√©!)
- Laisser une personne parler tout le temps
- Chercher dans le code pendant les questions (connaissez votre projet!)
- Improviser la d√©mo sans sc√©nario pr√©par√©

üéØ POINTS CL√âS √Ä METTRE EN AVANT :
- Contraintes d'int√©grit√© (CHECK, UNIQUE, CASCADE, SET NULL)
- Architecture MVC bien s√©par√©e
- Gestion d'√©tat complexe avec SESSION
- Enregistrement en base avec tables PARTIES et JOURNAL
- Logique m√©tier avanc√©e (combat, sorts, conditions de victoire)
- Interface utilisateur riche avec feedback visuel

================================================================================
                                BONNE CHANCE ! üçÄ
================================================================================
